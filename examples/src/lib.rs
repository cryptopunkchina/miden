use env_logger::Env;
use miden::{ProgramInputs, ProofOptions, Script};
use structopt::StructOpt;

pub mod fibonacci;
// mod collatz;
mod conditional;
// mod merkle;
mod comparison;

// EXAMPLE
// ================================================================================================

pub struct Example {
    pub program: Script,
    pub inputs: ProgramInputs,
    pub pub_inputs: Vec<u64>,
    pub num_outputs: usize,
    pub expected_result: Vec<u64>,
}

// EXAMPLE OPTIONS
// ================================================================================================

#[derive(StructOpt, Debug)]
#[structopt(name = "Miden", about = "Miden examples")]
pub struct ExampleOptions {
    #[structopt(subcommand)]
    pub example: ExampleType,

    /// Security level for execution proofs generated by the VM
    #[structopt(short = "s", long = "security", default_value = "96bits")]
    security: String,
}

impl ExampleOptions {
    pub fn get_proof_options(&self) -> ProofOptions {
        match self.security.as_str() {
            "96bits" => ProofOptions::with_96_bit_security(),
            "128bits" => ProofOptions::with_128_bit_security(),
            other => panic!("{} is not a valid security level", other),
        }
    }
}

#[derive(StructOpt, Debug)]
//#[structopt(about = "available examples")]
pub enum ExampleType {
    /// Compute a Fibonacci sequence of the specified length
    Fib {
        /// Length of Fibonacci sequence
        #[structopt(short = "n", default_value = "1024")]
        sequence_length: usize,
    },
}

// TESTS
// ================================================================================================

#[cfg(test)]
pub fn test_example(example: Example, fail: bool) {
    let Example {
        program,
        inputs,
        pub_inputs,
        num_outputs,
        expected_result,
    } = example;

    let (mut outputs, proof) =
        miden::execute(&program, &inputs, num_outputs, &ProofOptions::default()).unwrap();

    assert_eq!(
        expected_result, outputs,
        "Program result was computed incorrectly"
    );

    if fail {
        outputs[0] += 1;
        assert!(miden::verify(*program.hash(), &pub_inputs, &outputs, proof).is_err())
    } else {
        assert!(miden::verify(*program.hash(), &pub_inputs, &outputs, proof).is_ok());
    }
}

pub fn init_log(log_level: &str){
    use std::io::Write;
    use chrono::Local;
    // let env = env_logger::Env::default().filter_or(env_logger::DEFAULT_FILTER_ENV,log_level);
    // env_logger::Builder::from_env(env).format(|buf,record|{
    //     writeln!(
    //         buf,
    //         "{} {} [{}:{}] {} {}",
    //         Local::now().format("%Y-%m-%d %H:%M:%S"),
    //         record.level(),
    //         record.module_path().unwrap_or("<unnamed>"),
    //         record.line().unwrap_or(0),
    //         record.target(),
    //         &record.args()
    //     )
    // }).init();
    env_logger::Builder::from_env(Env::default().default_filter_or("debug")).init();
    // let env = env_logger::Env::new().filter_or(env_logger::DEFAULT_FILTER_ENV, log_level).write_style_or("MY_LOG_STYLE", "always");
    // env_logger::Builder::from_env(env)
    //     .format(|buf, record| {
    //         writeln!(buf, "{}: {}", record.level(), record.args())
    //     })
    //     .is_test(true).try_init();
    println!("log config success");
}